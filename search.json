[{"title":"深拷贝与浅拷贝","url":"/2018/12/15/深拷贝与浅拷贝/","content":"\n# 深拷贝与浅拷贝\n**深拷贝与浅拷贝是只针对引用类型来讲的，因为基本类型赋值是传值，而对象赋值是传引用。**\n1. 浅拷贝：只拷贝对象引用。将源对象对应的内存地址传给了target\n2. 深拷贝：源对象完整复制了一份存在另外一个内存中，然后将新复制的对象的地址传给了target。\n\n**区别：**如果是浅拷贝，则修改源对象会影响目标对象，反过来亦同。**浅拷贝无法拷贝function属性**;深拷贝则不会影响\n```javascript\n\nlet target={},\n    srcObj = {\n        name:\"llz\",\n        body:{\n            hair:\"brown\",\n            style:\"slender\"\n        }\n    }\n\n/**浅拷贝**/\ntarget = srcObj;\nconsole.dir(target);    //{ name: 'llz', body: { hair: 'brown', style: 'slender' } }\nsrcObj.name=\"www\";\nconsole.dir(srcObj);    //{ name: 'www', body: { hair: 'brown', style: 'slender' } }\nconsole.dir(target);    //{ name: 'www', body: { hair: 'brown', style: 'slender' } }\n\n/**深拷贝**/\ntarget = JSON.parse(JSON.stringify(srcObj));\nconsole.dir(target);    //{ name: 'llz', body: { hair: 'brown', style: 'slender' } }\nsrcObj.name=\"www\";\nconsole.dir(srcObj);    //{ name: 'www', body: { hair: 'brown', style: 'slender' } }\nconsole.dir(target);    //{ name: 'llz', body: { hair: 'brown', style: 'slender' } }\n\n```\n\n## 浅拷贝\n1. 直接赋值\n2. Object.assign(target,...src)   \n以下代码验证了assign是浅拷贝：\n    ```javascript\n    let target={},\n    srcObj = {\n        name:\"llz\",\n        body:{\n            hair:\"brown\",\n            style:\"slender\"\n        },\n        say(){\n            console.log(\"llz\")\n        }\n    };\n\n    target=Object.assign({},srcObj);\n    console.log(JSON.stringify(target));       //{\"name\":\"llz\",\"body\":{\"hair\":\"brown\",\"style\":\"slender\"}}\n    \n    srcObj.body.hair=\"modified\";\n    console.dir(JSON.stringify(srcObj));    //{\"name\":\"llz\",\"body\":{\"hair\":\"modified\",\"style\":\"slender\"}}\n    console.dir(JSON.stringify(target));    //{\"name\":\"llz\",\"body\":{\"hair\":\"modified\",\"style\":\"slender\"}}\n    target.say();                           //llz\n    ```\n  \n  >如果写成 let target = Object.assign(src)，则相当于直接赋值let target = src。\n\n## 深拷贝\n1. JSON.parse(JSON.stringify(src))\n    ```javascript\n    let target = JSON.parse(JSON.stringify(srcObj));\n    \n    ```\n1. $.extend()\n    \n    ```javascript\n    jQuery.extend = jQuery.fn.extend = function() {\n      var options, name, src, copy, copyIsArray, clone,\n        target = arguments[ 0 ] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n      // Handle a deep copy situation\n      if ( typeof target === \"boolean\" ) {\n        deep = target;\n\n        // Skip the boolean and the target\n        target = arguments[ i ] || {};\n        i++;\n    }\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t/* Don't bring in undefined values，\n\t\t\t\t* function props match here\n\t\t\t\t* primitive props match here\n\t\t\t\t*/\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n```\n2. _.cloneDeep(src)  \n\n  ```javascript\n  function baseClone(value, bitmask, key, object, stack) {\n    let result\n    const isDeep = bitmask & CLONE_DEEP_FLAG\n    const isFlat = bitmask & CLONE_FLAT_FLAG\n    const isFull = bitmask & CLONE_SYMBOLS_FLAG\n\n    /**\n    * 非object（包括plain object和array），非function\n    */  \n    if (!isObject(value)) {\n      return value\n    }\n\n    const isArr = Array.isArray(value)\n    const tag = getTag(value)\n    if (isArr) {\n      result = initCloneArray(value)\n      if (!isDeep) {\n        return copyArray(value, result)\n      }\n    } else {\n      const isFunc = typeof value == 'function'\n\n      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n        /**\n        * initCloneObject 与 {}的区别是initCloneObject返回的对象是value的原型。\n        * 这样以后result就继承了原型上的方法，比如map结构的set方法和set结构的add方法\n        */\n        result = (isFlat || isFunc) ? {} : initCloneObject(value)\n        if (!isDeep) {\n          return isFlat\n            ? copySymbolsIn(value, baseAssignIn(result, value))\n            : copySymbols(value, baseAssign(result, value))\n        }\n      } else {\n        if (isFunc || !cloneableTags[tag]) {\n          return object ? value : {}\n        }\n        result = initCloneByTag(value, tag, isDeep)\n      }\n    }\n    \n    if (tag == mapTag) {\n      value.forEach((subValue, key) => {\n        result.set(key, baseClone(subValue, bitmask, key, value, stack))\n      })\n      return result\n    }\n\n    if (tag == setTag) {\n      value.forEach((subValue) => {\n        result.add(baseClone(subValue, bitmask, subValue, value, stack))\n      })\n      return result\n    }\n\n    const keysFunc = isFull\n      ? (isFlat ? getAllKeysIn : getAllKeys)\n      : (isFlat ? keysIn : keys)\n\n    const props = isArr ? undefined : keysFunc(value)\n    arrayEach(props || value, (subValue, key) => {\n      if (props) {\n        key = subValue\n        subValue = value[key]\n      }\n      // Recursively populate clone (susceptible to call stack limits).\n      assignValue(result, key, baseClone(subValue, bitmask, key, value, stack))\n    })\n    return result\n  }\n\n\n  /*****************************assign******************************/\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__') {\n      Object.defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': true,\n        'value': value,\n        'writable': true\n      })\n    } else {\n      object[key] = value\n    }\n  }\n  ```\n\n  概括起来讲是针对原始数据(primitive)和引用数据(reference)分别处理。原始数据直接赋值就好；引用数据则继续遍历属性，数组遍历元素，对象遍历属性，函数）,_.cloneDeep最后递归调用defineProperty将源对象拷贝到目标对象上,而jQuery.extend则是直接将原始数据赋值（=）到目标对象上。\n\n\n\n# 参考\n## [自有属性与枚举属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)\n1. 枚举属性\n  对象常量的属性；通过defineProperty(默认enumerable为false)定义为enumerable的属性；对象原型链上的属性。\n2. 自有属性。可通过Object.getOwnProperty系列方法返回的属性。\n  对象常量的属性；通过defineProperty定义的属性（包括可枚举和不可枚举）\n\n原型链上的属性是对象的共有属性，其它的属性都是自有属性。Object.keys(obj) 会返回自有可枚举属性。for(key in obj) 会遍历到所有可枚举属性，包括原型链上的属性。Object.getOwnPropertyNames(obj) 会返回所有的自有属性。\n\n## [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)   \n> Object.assign方法只会拷贝源对象的**自身的**属性 。\n\n","tags":["javascript","clone","深拷贝","浅拷贝"],"categories":["JavaScript"]}]